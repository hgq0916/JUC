#### Executors

1.创建单个线程的线程池

保证任务的顺序执行

面试：为什么要有单线程的线程池？

线程池有任务队列，有生命周期管理

2.创建缓存线程池

核心线程数为0，每一个任务都创建一个线程

线程执行完任务后，60s内如果有任务则使用这个线程，如果没有任务则超过60s线程被销毁

使用场景：任务不均匀，但是要保证任务必须有线程去处理

3.创建固定线程池

最大线程数和核心线程数相同

使用场景：任务比较均匀

![1603979789244](9.详解线程池-自定义线程池-JDK自带线程池-ForkJoin，源码解析等(二).assets/1603979789244.png)

等待时间：线程让出cpu的时间

计算时间：线程使用cpu的时间

生产环境需要压测确定最终的线程池大小

#### 创建定时器线程池

用来执行定时任务，使用DelayedWorkQueue

newSchuledThreadPool

**面试**：假设提供一个闹钟服务，订阅这个服务的人特别多，10亿人，怎么优化？
任务分发到多个服务器，然后使用定时任务线程池处理

####　concurrent VS parallel

并发指任务提交，并行指任务执行

并行是并发的子集

并发是很多任务同时交给一个cpu去执行，并行是多个任务在多个cpu上同时运行

#####　练习：求１－２００００之间的质数，使用线程池

####　ThreadPoolExecutor源码解析

#### WorkStealingPool

每个线程都有自己的队列，如果自己的队列为空，从其他的队列获取一个任务执行

![1604024252474](9.详解线程池-自定义线程池-JDK自带线程池-ForkJoin，源码解析等(二).assets/1604024252474.png)

push & pop:不需要加锁

poll:需要加锁

#### ForkJoinPool

把大任务切分成小任务，执行完成后小任务把结果交给父任务进行汇总

![1604024699338](9.详解线程池-自定义线程池-JDK自带线程池-ForkJoin，源码解析等(二).assets/1604024699338.png)

ForkJoinTask:可以切分的任务

RecursiveAction: 递归方式切分任务，不带返回值

RecursiveTask:递归方式切分任务，带返回值

练习：求100个万随机数的总和

#### ParallelStream

把任务切分成子任务，底层实现是ForkJoinPool

![1604026343612](9.详解线程池-自定义线程池-JDK自带线程池-ForkJoin，源码解析等(二).assets/1604026343612.png)

